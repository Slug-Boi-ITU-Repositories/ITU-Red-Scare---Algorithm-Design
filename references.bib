
@incollection{sedgewick_algorithms_2011,
	address = {Upper Saddle River},
	edition = {4th ed},
	title = {Algorithms},
	isbn = {9780321573513},
	language = {eng},
	publisher = {Addison-Wesley},
	author = {Sedgewick, Robert and Wayne, Kevin Daniel},
	year = {2011},
	pages = {18},
}

@misc{holm_bit-ds_2025,
	title = {bit-ds: {A} {Python} library for the {Binary} {Indexed} {Tree} data structure.},
	shorttitle = {bit-ds},
	url = {https://pypi.org/project/bit-ds/},
	author = {Holm, Theis Per and Brandt, August Kofoed},
	month = may,
	year = {2025},
	keywords = {BIT,, binary indexed tree,, data structure,, fenwick tree,, pyo3,, python,, rust},
}

@misc{wikipedia_fenwick_2025,
	title = {Fenwick tree},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Fenwick_tree&oldid=1282309568},
	abstract = {A Fenwick tree is most easily understood using a one-based array A [ n ] \{{\textbackslash}displaystyle A[n]\} with n \{{\textbackslash}displaystyle n\} values. Using half-open interval syntax, let A ( i , j ] = \{ A [ k ] \} k = i + 1 j , \{{\textbackslash}displaystyle A(i,j]={\textbackslash}\{A[k]{\textbackslash}\}\_\{k=i+1\}{\textasciicircum}\{j\},\} the range from i \{{\textbackslash}displaystyle i\} (exclusive) to j \{{\textbackslash}displaystyle j\} (inclusive). The corresponding Fenwick array F [ n ] \{{\textbackslash}displaystyle F[n]\} stores the range sums F [ i ] = ∑ A ( i − lsb ⁡ ( i ) , i ] \{{\textbackslash}displaystyle {\textbackslash}textstyle F[i]={\textbackslash}sum A(i-{\textbackslash}operatorname \{lsb\} (i),i]\}. That is, the sum of lsb ⁡ ( i ) \{{\textbackslash}displaystyle {\textbackslash}operatorname \{lsb\} (i)\} values ending with and including A [ i ] \{{\textbackslash}displaystyle A[i]\}.},
	language = {en},
	urldate = {2025-05-13},
	journal = {Wikipedia},
	publisher = {Wikipedia},
	author = {Wikipedia},
	month = mar,
	year = {2025},
	note = {Page Version ID: 1282309568},
}

@misc{python3_heapq_2025,
	title = {heapq — {Heap} queue algorithm},
	url = {https://docs.python.org/3/library/heapq.html},
	abstract = {Source code: Lib/heapq.py This module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm. Heaps are binary trees for which every parent node has a va...},
	language = {en},
	urldate = {2025-05-13},
	journal = {Python documentation},
	author = {Python3},
	month = may,
	year = {2025},
}

@misc{holm_slug-boibinary-indexed-tree_2025,
	title = {Slug-{Boi}/binary-indexed-tree},
	copyright = {MIT},
	url = {https://github.com/Slug-Boi/binary-indexed-tree},
	abstract = {This is a Rust Pyo3 implementation of a Binary Indexed Tree aka Fenwick Tree},
	urldate = {2025-05-13},
	author = {Holm, Theis Per and Brandt, August Kofoed},
	month = may,
	year = {2025},
	note = {original-date: 2025-04-22T19:11:35Z},
}

@incollection{mehlhorn_algorithms_2008,
	address = {Berlin, Heidelberg},
	title = {Algorithms and {Data} {Structures}: {The} {Basic} {Toolbox}},
	isbn = {9783540779773 9783540779780},
	shorttitle = {Algorithms and {Data} {Structures}},
	language = {eng},
	publisher = {Springer Berlin Heidelberg},
	author = {Mehlhorn, Kurt and Sanders, Peter},
	year = {2008},
	pages = {52--53},
}

@incollection{mehlhorn_algorithms_2008-1,
	address = {Berlin, Heidelberg},
	title = {Algorithms and {Data} {Structures}: {The} {Basic} {Toolbox}},
	isbn = {9783540779773 9783540779780},
	shorttitle = {Algorithms and {Data} {Structures}},
	language = {eng},
	publisher = {Springer Berlin Heidelberg},
	author = {Mehlhorn, Kurt and Sanders, Peter},
	year = {2008},
	pages = {23},
}

@article{munro_implicit_1980,
	title = {Implicit data structures for fast search and update},
	volume = {21},
	issn = {0022-0000},
	url = {https://www.sciencedirect.com/science/article/pii/0022000080900379},
	doi = {10.1016/0022-0000(80)90037-9},
	abstract = {We consider representations of data structures in which the relative ordering of the values stored is implicit in the pattern in which the elements are retained, rather than explicit in pointers. Several implicit schemes for storing data are introduced to permit efficient implementation of the instructions insert, delete and search. θ(N12) basic operations are shown to be necessary and sufficient, in the worst case, to perform these instructions provided that the data elements are kept in some fixed partial order. We demonstrate, however, that the upper bound can be reduced to O(N13 log N) if arrangements other than fixed partial orders are used.},
	number = {2},
	urldate = {2025-05-12},
	journal = {Journal of Computer and System Sciences},
	author = {Munro, J. Ian and Suwanda, Hendra},
	month = oct,
	year = {1980},
	pages = {236--250},
}

@misc{missagia_manim_2025,
	title = {Manim {DSA}},
	url = {https://github.com/F4bbi/manim-dsa},
	abstract = {A Manim plugin to animate common data structures and algorithms.},
	urldate = {2025-05-12},
	author = {Missagia, Fabio},
	month = may,
	year = {2025},
	note = {original-date: 2024-08-30T19:24:53Z},
}

@incollection{sedgewick_algorithms_2011-1,
	address = {Upper Saddle River},
	edition = {4th ed},
	title = {Algorithms},
	isbn = {9780321573513},
	language = {eng},
	publisher = {Addison-Wesley},
	author = {Sedgewick, Robert and Wayne, Kevin Daniel},
	year = {2011},
	pages = {396},
}

@misc{boba5551_binary_2018,
	type = {Education},
	title = {Binary {Indexed} {Trees}},
	shorttitle = {{BIT}},
	url = {https://www.topcoder.com/thrive/articles/Binary%20Indexed%20Trees},
	abstract = {Topcoder is a crowdsourcing marketplace that connects businesses with hard-to-find expertise. The Topcoder Community includes more than one million of the world’s top designers, developers, data scientists, and algorithmists. Global enterprises and startups alike use Topcoder to accelerate innovation, solve challenging problems, and tap into specialized skills on demand.},
	language = {en},
	urldate = {2025-05-05},
	journal = {Topcoder},
	author = {boba5551},
	month = oct,
	year = {2018},
}

@misc{aumuller_aps-24_2024,
	title = {Aps-24 {Supercomputer} solution - {Fenwick} tree implementation},
	url = {https://github.itu.dk/algorithms/aps-24},
	abstract = {Contribute to algorithms/aps-24 development by creating an account on GitHub.},
	language = {en},
	urldate = {2025-05-05},
	journal = {GitHub Enterprise},
	author = {Aumüller, Martin and Jacob, Riko and Breum, Simon Martin},
	year = {2024},
}

@misc{brandt_kattis_assignments_katti_bois_2024,
	title = {kattis\_assignments\_katti\_bois - {Fenwick} tree implementation},
	url = {https://github.com/Slug-Boi/kattis_assignments_katti_bois/blob/55793d2f4f8bfec1018b7787a50c3d49f53b292b/segment_trees/purrfect_trees/submissions/wrong_answer/Fenwick.py#L4},
	urldate = {2025-05-05},
	journal = {Github},
	author = {Brandt, August Kofoed and Holm, Theis Per and Lolk, Alexander},
	year = {2024},
}

@incollection{durr_competitive_2020,
	address = {Cambridge},
	title = {Competitive programming in {Python}: 128 algorithms to develop your coding skills},
	isbn = {9781108591928},
	shorttitle = {Competitive programming in {Python}},
	abstract = {"Want to kill it at your job interview in the tech industry? Want to win that coding competition? Learn all the algorithmic techniques and programming skills you need from two experienced coaches, problem setters, and jurors for coding competitions. The authors highlight the versatility of each algorithm by considering a variety of problems and show how to implement algorithms in simple and efficient code. What to expect: * Master 128 algorithms in Python. * Discover the right way to tackle a problem and quickly implement a solution of low complexity. * Classic problems like Dijkstra's shortest path algorithm and Knuth-Morris-Pratt's string matching algorithm, plus lesser known data structures like Fenwick trees and Knuth's dancing links. * A framework to tackle algorithmic problem solving, including: Definition, Complexity, Applications, Algorithm, Key Information, Implementation, Variants, In Practice, and Problems. * Python code in the book and on the companion website"--},
	language = {eng},
	publisher = {Cambridge University Press},
	author = {Dürr, Christoph and Vie, Jill-Jênn},
	translator = {Gibbons, Greg and Gibbons, Danièle},
	year = {2020},
	pages = {79},
}

@article{bille_fast_2017,
	title = {Fast {Dynamic} {Arrays}: 25th {European} {Symposium} on {Algorithms} ({ESA} 2017)},
	issn = {978-3-95977-049-1},
	shorttitle = {Fast {Dynamic} {Arrays}},
	doi = {10.4230/LIPIcs.ESA.2017.16},
	abstract = {We present a highly optimized implementation of tiered vectors, a data structure for maintaining
a sequence of n elements supporting access in time O(1) and insertion and deletion in time O(n)
for  {\textgreater} 0 while using o(n) extra space. We consider several different implementation optimizations
in C++ and compare their performance to that of vector and set from the standard library on
sequences with up to 108 elements. Our fastest implementation uses much less space than set
while providing speedups of 40× for access operations compared to set and speedups of 10.000×
compared to vector for insertion and deletion operations while being competitive with both data
structures for all other operations.},
	journal = {Proceedings of 5th Annual European Symposium on Algorithms},
	author = {Bille, Philip and Christiansen, Anders Roy and Ettienne, Mikko Berggren and Gørtz, Inge Li},
	year = {2017},
	keywords = {Dynamic Arrays, Tiered Vectors},
	pages = {16:1--16:13},
}
