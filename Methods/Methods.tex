\section{Methods}

% TODO add pretty stuff to replace Thore's fluff with
%For problem A, I solved each instance $G$ by $\cdots$\footnote{Describe what you did.
%  Use words like ``building a inverse anti-tree without self-loops where each vertex in $G$ is presented by a Strogatz--Wasserman shtump.
%  I then performed a standard longest hash sorting using the algorithm of Bronf (Algorithm 5 in [1]).''
%  Be neat, brief, and precise.}
%The running time of this algorithm is $\cdot$, and my implementation spends $\cdots$ seconds on the instance $\cdots$ with  $n=\cdots$.

%I solved problem $\cdots$ for all $\cdots$\footnote{For instance, “planar, bipartite”} graphs using $\cdots$.

%I was unable to solve problem $\cdots$ except for the $\cdots$ instances.
%This is because, in generality, this problem is $\cdots$. 
%To see this, consider the following reduction from $\cdots$.
%Let $\ldots$ 

%I was also unable to solve $\cdots$ for $\cdots$, but I don’t know why.\footnote{Remove or expand as necessary.}

\subsection{None}
Description
*Return the length of the shortest s,t-path*

Strategy
Remove $R - \{s,t\}$ from $V(G)$  
*Probably if statement to ignore reds when queuing*  
`BFS(s,t)`

Analysis
$O(V+E)$  


\subsection{Some}
Description
*Return whether there is a path from s to t that includes a vertex from R (true/false)*

Strategy
We don't can't solve might be 

Analysis

\subsection{Many}
Description
*Return the maximum number of red vertices on any path from s to t*

Strategy
This is probably a longest path kinda deal


Analysis
Reduction to longest path (NP-hard baby)

\subsection{Few}
Description
*Find any path with minimum reds*

Strategy
Dijkstra with all black having cost 0 and reds having 1 

Analysis
$O(V^2)$

\subsection{Alternate}

Description
*Return whether there is a path form s to t that alternates between red and non-red vertices (true/false)*

Strategy
`BFS(s,t)`
with if statement that checks if next is alternate color?

Analysis
$O(V+E)$

